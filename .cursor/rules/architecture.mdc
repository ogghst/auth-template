---
description: Develop a secure full-stack application with GitHub authentication, featuring a Next.js 14 frontend, NestJS 10 backend, auth.js5 authentication framework,, SQLite database managed through TypeORM. The application will follow a monorepo structure with Turborepo.  User Stories & Use Cases Authentication Flow  First-Time User Registration  User visits application and sees login page User clicks "Login with GitHub" button User authorizes the application on GitHub Application creates new user record with GitHub profile data User is redirected to onboarding page to complete profile User is then redirected to dashboard   Returning User Login  User visits application and sees login page User clicks "Login with GitHub" button Application recognizes returning user User is redirected directly to dashboard   Session Management  User's JWT token expires after 15 minutes Frontend automatically attempts to refresh token If refresh fails, user is prompted to login again User can manually log out, invalidating their token   Access Control  Unauthenticated users cannot access protected routes (dashboard, settings, etc.) Authenticated users can only access their own data User receives appropriate error messages when access is denied   Profile Management  User can view their GitHub profile information on dashboard User can view their session information (login time, expiration) User can view their login history (timestamps, devices)    Technical Specifications Monorepo Structure  Authentication Technical Flow  Frontend Authentication:  Auth.js handles GitHub OAuth flow Store auth state in secure HTTP-only cookies Implement client-side redirect protection Create API interceptor to handle 401 responses   Backend Authentication:  NestJS Passport integration with GitHub strategy JWT issuance with 15-minute expiration JWT refresh functionality with proper validation Security headers and CSRF protection   Database Schema:  User entity with GitHub profile data Token entity with metadata and relations Session tracking with device fingerprinting Audit logs for security events    Package-Specific Requirements 1. Config Package  ESLint configuration (flat config) TypeScript configuration Jest configuration Shared Prettier rules Git hooks setup (Husky)  2. Shared Package  User interfaces/types Token interfaces Auth-related DTOs API response types Utility functions (validation, date handling) Error types and handling  3. Storage Package  TypeORM entity definitions  User entity Token entity Session entity AuditLog entity   Repository implementations Migration scripts SQLite configuration Seed data for development  4. Backend Package (NestJS)  Authentication module  GitHub strategy JWT strategy Token service   User module  Profile controller User service   Security module  Rate limiting CSRF protection Security headers   Logging module  Audit logging Security event tracking    5. Frontend Package (Next.js)  Authentication components  Login page Protected route wrapper Auth context provider   Dashboard pages  User profile section Session information display Login history   API abstraction layer  Request interceptors Response handling Error handling   UI components with MUI 5  Responsive layout Loading states Error messages    Testing Requirements  Unit tests for core functionality Integration tests for API endpoints Authentication flow tests Error handling tests Performance tests for critical paths  DevOps Considerations  GitHub Actions for CI/CD Pre-commit hooks for code quality Database migration strategy Environment variable management Logging and monitoring setup  Implementation Steps  Initialize monorepo with pnpm and Turborepo Set up config package with ESLint, TypeScript Create shared package with core types Implement storage package with TypeORM entities Develop backend authentication flow Create frontend with Next.js and Auth.js Integrate frontend and backend Implement testing across all packages Document the application  Success Criteria  Users can successfully authenticate with GitHub JWT tokens properly expire and refresh Protected routes are secure User data is displayed correctly Error handling is graceful and informative Code quality passes ESLint/Prettier validation Tests cover critical functionality Application performance meets expectations
globs: 
alwaysApply: true
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to
